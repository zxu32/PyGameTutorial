import mathimport random as randclass Particle:    def __init__(self, x, y, size, mass, color=(0, 0, 255)):        self.x = x        self.y = y        self.size = size        self.color = color        self.thickness = 0        self.speed = 1        self.angle = 0        self.mass = mass        self.elasticity = 0.9        self.drag = 0    def move(self):        self.x += math.sin(self.angle) * self.speed        self.y -= math.cos(self.angle) * self.speed    def accelerate(self, vector):        (self.angle, self.speed) = addVectors(self.angle, self.speed, vector[0], vector[1])    def experienceDrag(self):        self.speed *= self.drag    def mouseMove(self, x, y):        dx = x - self.x        dy = y - self.y        self.angle = math.atan2(dy, dx) + 0.5 * math.pi        self.speed = math.hypot(dx, dy) * .1    def attract(self, other):        dx = self.x - other.x        dy = self.y - other.y        dist = math.hypot(dx, dy)        theta = math.atan2(dy, dx)        force = .1 * self.mass * other.mass / dist**2        vectorSelf = (theta - 0.5 * math.pi, force/self.mass)        # the angle is calculated as theta - pi because pygame's coordinate system is different        # from regular cartesian system with positive y axis pointing downward        vectorOther = (theta + 0.5 * math.pi, force/other.mass)        self.accelerate(vectorSelf)        other.accelerate(vectorOther)class Environment:    def __init__(self, width, height, **kwargs):        self.width = width        self.height = height        self.particles = []        self.color = kwargs.get('color', (255, 255, 255))        self.mass_of_air = 0.2        self.wallElasticity = 0.75        self.acceleration = (0, 0)  # acceleration vector        self.hasBoundaries = self.width and self.width        self.springs = []        self.particle_functions1 = []        self.particle_functions2 = []        self.function_dict = {'move': (1, lambda p: p.move()),                              'drag': (1, lambda p: p.experienceDrag()),                              'bounce': (1, lambda p: self.bounce(p)),                              'accelerate': (1, lambda p: p.accelerate(self.acceleration)),                              'collide': (2, lambda p1, p2: collide(p1, p2)),                              'attract': (2, lambda p1, p2: p1.attract(p2)),                              'combine': (2, lambda p1, p2: combine(p1, p2))}    def addParticles(self, n=1, **kwargs):        for i in range(0, n):            size_part = kwargs.get('size', rand.randint(10, 20))            mass_part = kwargs.get('mass', rand.randint(100, 10000))            x_coord = kwargs.get('x', rand.randint(size_part, self.width - size_part))            y_coord = kwargs.get('y', rand.randint(size_part, self.height - size_part))            p = Particle(x_coord, y_coord, size_part, mass_part)            p.speed = kwargs.get('speed', rand.random())            p.angle = kwargs.get('angle', rand.uniform(0, math.pi * 2))            # p.color = (255 - p.mass**0.6, 255 - p.mass**0.6, 255)            p.color = kwargs.get('color', (0, 0, 255))  # alternative way to init p.color            p.drag = (p.mass/(p.mass + self.mass_of_air)) ** p.size            self.particles.append(p)    def addSpring(self, p1, p2, length=50, strength=0.5):        self.springs.append(Spring(self.particles[p1], self.particles[p2], length, strength))    def bounce(self, p):        if p.x > self.width - p.size:            p.x = 2 * (self.width - p.size) - p.x            p.angle = -p.angle            p.speed *= self.wallElasticity        if p.x < p.size:            p.x = 2 * p.size - p.x            p.angle = -p.angle            p.speed *= self.wallElasticity        if p.y > self.height - p.size:            p.y = 2 * (self.height - p.size) - p.y            p.angle = math.pi - p.angle            p.speed *= self.wallElasticity        if p.y < p.size:            p.y = 2 * p.size - p.y            p.angle = math.pi - p.angle            p.speed *= self.wallElasticity    def update(self):        for i, particle in enumerate(self.particles):            for f in self.particle_functions1:                f(particle)            for particle2 in self.particles[i+1:]:                for f in self.particle_functions2:                    f(particle, particle2)            for spring in self.springs:                spring.update()    def findParticles(self, x, y):        for p in self.particles:            if math.hypot(p.x - x, p.y - y) <= p.size:                return p    def addFunctions(self, function_list):        for f in function_list:            (n, f) = self.function_dict.get(f, (-1, 0))            if n == 1:                self.particle_functions1.append(f)            elif n == 2:                self.particle_functions2.append(f)            else:                print('No such function: {}'.format(f))class Spring:    def __init__(self, p1, p2, length=50, strength=0.5):        self.p1 = p1        self.p2 = p2        self.length = length        self.strength = strength    def update(self):        dx = self.p1.x - self.p2.x        dy = self.p1.y - self.p2.y        dist = math.hypot(dx, dy)        theta = math.atan2(dy, dx)        force = (self.length - dist) * self.strength        self.p1.accelerate((theta + 0.5 * math.pi, force/self.p1.mass))        self.p2.accelerate((theta - 0.5 * math.pi, force/self.p2.mass))# take 2 vectors with same origin, return resultant vectordef addVectors(angle1, length1, angle2, length2):    x = math.sin(angle1)*length1 + math.sin(angle2)*length2    y = math.cos(angle1)*length1 + math.cos(angle2)*length2    length = math.hypot(x, y)    angle = 0.5 * math.pi - math.atan2(y, x)    return angle, length# handling colliding between two particlesdef collide(p1, p2):    d_x = p1.x - p2.x    d_y = p1.y - p2.y    distance = math.hypot(d_x, d_y)    if distance < p1.size + p2.size:        angle = math.atan2(d_y, d_x) + 0.5*math.pi        total_mass = p1.mass + p2.mass        (p1.angle, p1.speed) = addVectors(p1.angle, p1.speed*(p1.mass - p2.mass)/total_mass,                                          angle, 2*p2.speed*p2.mass/total_mass)        (p2.angle, p2.speed) = addVectors(p2.angle, p2.speed*(p2.mass - p1.mass)/total_mass,                                          angle+math.pi, 2*p1.speed*p1.mass/total_mass)        '''        # code below is a simpler version of collision simulating, it reflects the        # angle and exchanges the speed of the particles.        p1.angle = 2*tangent - p1.angle        p2.angle = 2*tangent - p2.angle        (p1.speed, p2.speed) = (p2.speed, p1.speed)        '''        p1.speed *= p1.elasticity        p2.speed *= p2.elasticity        # code below solves 'sticking' problem        overlap = 0.5*(p1.size + p2.size - distance + 1)        p1.x += math.sin(angle)*overlap        p1.y -= math.cos(angle)*overlap        p2.x -= math.sin(angle)*overlap        p2.y += math.cos(angle)*overlap# once two particles collide, combine themdef combine(p1, p2):    if math.hypot(p1.x - p2.x, p1.y - p2.y) < (p1.size + p2.size):        totalMass = p1.mass + p2.mass        p1.x = (p1.x * p1.mass + p2.x * p2.mass)/totalMass        p1.y = (p1.y * p1.mass + p2.y * p2.mass)/totalMass        (p1.angle, p1.speed) = addVectors(p1.angle, (p1.speed * p1.mass)/totalMass,                                          p2.angle, (p2.speed * p2.mass)/totalMass)        p1.speed *= p1.elasticity * p2.elasticity        p1.mass += p2.mass        p1.collideWith = p2